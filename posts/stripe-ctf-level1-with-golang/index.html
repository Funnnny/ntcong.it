<!DOCTYPE HTML>

<html lang="en-us">

<head>
	<meta charset="utf-8">
	<title>Stripe-CTF Level 1 with Golang - Cong Nguyen</title>
	<meta name="author" content="map[]">

	
	
	<meta name="description" content="">
	

	
	<meta name="HandheldFriendly" content="True">
	<meta name="MobileOptimized" content="320">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    
	<link rel="canonical" href="http://localhost:1313/posts/stripe-ctf-level1-with-golang/">
	<link href="http://localhost:1313//favicon.png" rel="shortcut icon">
	<link href="http://localhost:1313//css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="http://localhost:1313//css/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/post/">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
	</div>
</nav>
</header>
			</div>
		</div>
		<div class="mid-col">
			
			<div class="mid-col-container">
				<div id="content" class="inner">
					<div itemscope itemtype="http://schema.org/Blog">
					<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <h1 class="title" itemprop="name">Stripe-CTF Level 1 with Golang</h1>
	<div class="entry-content" itemprop="articleBody">

<p>This year&rsquo;s Stripe-CTF brings some interesting things to the table: Cryptocurrency. I&rsquo;ve already known about cryptocurrency and Bitcoin in general, but it&rsquo;s amazing how Bitcoin relates to Git.</p>

<p>The level is here:&nbsp;<a href="https://stripe-ctf.com/levels/1">https://stripe-ctf.com/levels/1</a></p>

<p>Basically, like Bitcoin, you have to find a block, in this case is a git commit. The commit must have its hash lower than the target difficulty, specified in the file difficulty.txt. You will compete against a bot, and you have to find and submit a block/commit before it does.</p>

<p>As I&rsquo;m learning Golang, I wrote my miner using it, and managed to bring to 1MHash/s. Some people are going higher, specifically those using OpenCL/GPU to mine.</p>

<h3 id="basic:08a8d9808c645f9e5c4f35caf364b6d7">Basic</h3>

<p>The first version of my code is very simple. First it will add myself a Gitcoin to the file &ldquo;LEDGER.txt&rdquo;, get the difficulty, and get the required parameters to build the commit. Those tasks will only do once per block found, so any code will work.</p>

<p><pre><code>diff = make([]byte, 0)
diffString := strings.Trim(doExec("cat", "difficulty.txt"), "\n")
for i := 0; i < len(diffString)/2; i++ {
     n, _ := strconv.ParseInt(diffString[i*2:i*2+2], 16, 0)
     diff = append(diff, byte(n))
}
tree = strings.Trim(doExec("git", "write-tree"), "\n")
parent = strings.Trim(doExec("git", "rev-parse", "HEAD"), "\n")
timestamp = strings.Trim(doExec("date", "+%s"), "\n")
</code></pre>
</p>

<p>I calculate diff as a byte array because SHA1 library returned the hash as an array, so I don&rsquo;t have to convert SHA1 everytime; doExec is just a function to run the command and return console output as a string. The commit hash can be calculate by SHA1 the string &ldquo;commit [len_commit]\0[commit_string]&ldquo;. The commit string can be built by this code:</p>

<p><pre><code>baseCommit = fmt.Sprintf("tree %s\nparent %s\nauthor CTF user &lt;%s@stripe-ctf.com&gt; %s +0000\ncommitter CTF user &lt;%s@stripe-ctf.com&gt; %s +0000\n\nFu[4]ny got a Gitcoin\nnonce 1", tree, parent, username, timestamp, username, timestamp)
</code></pre>
</p>

<p>You should already notice the last &ldquo;nonce 1&rdquo; in the commit string, I will replace it with &ldquo;nonce 2&rdquo; and so on until I find a commit with hash lower than difficulty. It&rsquo;s surprisingly simple:</p>

<p><pre><code>func getSHA1(n int) [20]byte {
 return sha1.Sum([]byte(baseCommitHash <complete id="goog_259276313">+ </complete>"\n"))
}
func isHashValid(hash [20]byte) bool {
 for i, char := range hash {
  if i >= len(diff) {
   return false
  }
  if char > diff[i] {
   return false
  }
  if char < diff[i] {
   return true
  }
 }
 return false
}
</code></pre>
</p>

<p>After finding a coin, I&rsquo;ll write the commit and push it, I was lazy and just pipe everything to command line. It works but maybe a little slow.</p>

<p><pre><code>func pushResult(result chan int, done chan bool) {
    var n int
    for {
        n = &lt;-result
        sem &lt;- 1  // Semaphore git command so only one git command at a time
        c1 := exec.Command("echo", getCommit(n, false))
        c2 := exec.Command("git", "hash-object", "-t", "commit", "--stdin", "-w")
        var err error
        c2.Stdin, err = c1.StdoutPipe()
        if err != nil {
            panic(err)
        }
        c2.Stdout = os.Stdout
        _ = c2.Start()
        _ = c1.Run()
        _ = c2.Wait()
        &lt;-sem
        doExec("git", "reset", "--hard", fmt.Sprintf("%x", getCommitSHA(n)))
        res := doExec("git", "push")
        if res != "error" {
            // done &lt;- true
            // do not stop, just wait for a restart
            time.Sleep(10 * time.Second)
        } else {
            log.Println("Error when push, waiting for miner to restart")
            time.Sleep(10 * time.Second)
        }
    }
}
</code></pre>
</p>

<p>Then I just loop nonce until I found a coin. I use a result channel to communicate between miner thread and pushResult thread, and a done channel to stop when I find a commit. The bot takes about 10 mins to find a block, with just this version I managed to beat it.</p>

<h3 id="optimize-further:08a8d9808c645f9e5c4f35caf364b6d7">Optimize further</h3>

<p>After finishing the task, I can join a Gitcoin instance with all players in Stripe-CTF. I knew that I have to optimize it because I can push it only to 200kH/s</p>

<p>Fortunately, Go has profiling built-in, so I can easily point out that, most of the time my program was waiting for fmt.Sprintf, because I used it to build the commit message.</p>

<p>So, because the commit is fixed, just the nonce changes, I was able to prebuilt the commit message and the commit hash, just by giving the commit the fixed length and nonce has 16 number. I thought I can create SHA1 with that prebuilt commit and boost the speed of SHA1 function a lot, but I can&rsquo;t, so removing fmt.Sprintf was good for me.</p>

<p>And by competing with more people, I have to monitor new block, and restart my miner with a new blockchain. I built a channel into the miner, and another gorountine to monitor and send stop signal.</p>

<p>Once in a while, the miner will check for stop signal and get out of the loop.</p>

<p><pre><code>select {
case msg := &lt;-stop:
    if msg {
        // fmt.Printf("Miner %d stopped! Last i is %d\n", begin, i)
        break jobOuter
    }
default:
}
</code></pre>
</p>

<p>The monitor function is pretty straightforward, I have two commit hash, last and current, if last commit has different hash than current commit, I do a git hard reset, and send a stop signal.</p>

<p><pre><code>func monitor(stop chan bool) {
    var hash, newHash string
    hash = strings.Trim(doExec("git", "rev-parse", "--short", "origin/master"), "\n")
    for {
        doExec("git", "fetch", "origin")
        newHash = strings.Trim(doExec("git", "rev-parse", "--short", "origin/master"), "\n")
        if hash != newHash {
            doExec("git", "reset", "--hard", "origin/master")
            // log.Println("New block found! Reseting miners!")
            stop &lt;- true
            hash = newHash
            time.Sleep(1 * time.Second)
        }
        time.Sleep(1 * time.Second)
    }
}
</code></pre>
</p>

<p>That&rsquo;s almost be all, things I can/should do better:</p>

<ol>
<li>I have to calculate SHA1 again everytime I change nonce. I should calculate a base SHA1, and feed nonce for each loop. I can&rsquo;t find anyway to do this now, so I choose to ignore.</li>
<li>Calling git by command line is bad, maybe use a git library. Sometimes a push does matter, so implement it directly with socket might be good (just the push)</li>
</ol>

<p>I ended the game with 756 point, with several Gitcoins found. It&rsquo;s very hard to find a coin because I only have 1.5MH/s with all my PCs, so I need a lucky moment to get one.</p>
</div></article>
					
						<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	
	</div>
	
</div>

					
					
					


				    </div>
				</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    Cong Nguyen

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
<script src="http://localhost:1313//js/slash.js"></script>
<script src="http://localhost:1313//js/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script></footer>
		</div>
	</div>
	
</body>
</html>
