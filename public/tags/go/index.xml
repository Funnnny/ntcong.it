<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Cong Nguyen</title>
    <link>http://blog.ntcong.it/tags/go/</link>
    <description>Recent content in Go on Cong Nguyen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Dec 2014 11:22:36 +0700</lastBuildDate>
    <atom:link href="http://blog.ntcong.it/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Goodbye Blogspot, Hello Hugo</title>
      <link>http://blog.ntcong.it/posts/goodbye-blogspot-hello-hugo/</link>
      <pubDate>Mon, 08 Dec 2014 11:22:36 +0700</pubDate>
      
      <guid>http://blog.ntcong.it/posts/goodbye-blogspot-hello-hugo/</guid>
      <description>

&lt;h1 id=&#34;goodbye-any-traditional-blogging-system:6bf65216e2bb0f20637aa35fde252b26&#34;&gt;Goodbye (any) traditional blogging system&lt;/h1&gt;

&lt;p&gt;I used Wordpress for like 8 years, wrote some plugins myself (some that I already published), eventually got tired of managing my own hosting, and switched to wordpress.com. Then Wordpress.com want 15 dollar a year just for custom domain feature, and I switched to Blogspot. I happily used Blogspot for a while, but even so, the experience is not that great. Some example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bloated: there are so many features I don&amp;rsquo;t use, and the feature I use, I have to code it in manually.&lt;/li&gt;
&lt;li&gt;Editor: I hate the WYSIWYG editor, it&amp;rsquo;s bloated (again) with the non-standard tag, bbcode. It&amp;rsquo;s easy to break with my horrible Internet. And it doesn&amp;rsquo;t behave the way I want it to. I wanted to use Markdown, but write in Markdown, then convert to HTML and copy to the WYSIWYG editor, it&amp;rsquo;s not a pleasant way.&lt;/li&gt;
&lt;li&gt;Ugly Themes: It seems that no one want to use a minialist theme with Blogspot (or even Wordpress). I&amp;rsquo;m happy to remove away most features for a minimalistic approach, but to no avail. Every minimal templates/themes want to retain the most core-feature (which is not a bad thing). I&amp;rsquo;m a horrible designer, I know very little about CSS, so in the end, it&amp;rsquo;s still a problem I had to deal with.&lt;/li&gt;
&lt;li&gt;Bloated website: The website bundle with a lot of useless things: some stupid Google&amp;rsquo;s javascript that I don&amp;rsquo;t bother to read, Google+ js, some other Google&amp;rsquo;s one, then some Google+, a lot of default Blogspot CSS, jQuery, api.js, source code highlighting script&amp;hellip;Every features I added, I had to add some javascript/library too.&lt;/li&gt;
&lt;li&gt;Always online: I used some offline clients, but the trust is: you will never know how your post display until you submit the post. Only to find some problem, and have to fire up the online editor. And the downtime, every person in the world tells me Google&amp;rsquo;s uptime is the best, but I occasionally find some problem with the editor, or the admin interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I can make myself a static website, I even had one before I use Wordpress (with a lot of marquee). I don&amp;rsquo;t write much anyway, but again I&amp;rsquo;m a horrible designer, the website would be ugly.&lt;/p&gt;

&lt;p&gt;Then I heard about Jekyll, and then Octopress, and some alternatives like Brunch, Hyde. But nothing catches my attention (maybe because I don&amp;rsquo;t really like Ruby). One day, I read about Hugo and decided it&amp;rsquo;s time to switch.&lt;/p&gt;

&lt;h1 id=&#34;hello-static-website-generator-hugo:6bf65216e2bb0f20637aa35fde252b26&#34;&gt;Hello static website generator (Hugo)&lt;/h1&gt;

&lt;p&gt;I install hugo, build some test page with it, and then deploy the page to Github Pages in like 30 minutes. And I really like it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Being able to write my post in my editor: I use vim-binding so writing in normal or WYSIWYG editor feels missing something&lt;/li&gt;
&lt;li&gt;I can host my own blog (so I can do whatever I want) and also don&amp;rsquo;t have to manage it, because it integrated nicely with my work flow: Markdown+Git+Github Pages.&lt;/li&gt;
&lt;li&gt;Markdown is amazing, no more weird problem with WYSIWYG.&lt;/li&gt;
&lt;li&gt;No more jQuery, no more google-prettify. Most things that can be done in server, like paginate and syntax highlighting, will be done when you regenerate your post. Less JS dependancy = real minimalistic website&lt;/li&gt;
&lt;li&gt;Go: Go is amazing and you should learn/use it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only thing bugs me right now is the lack of themes, and it requires you have some decent knowledge about Go to solve some quirks. But it also give me some reason to tinkering with my setup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stripe-CTF Level 1 with Golang</title>
      <link>http://blog.ntcong.it/posts/stripe-ctf-level1-with-golang/</link>
      <pubDate>Fri, 07 Feb 2014 17:36:17 +0700</pubDate>
      
      <guid>http://blog.ntcong.it/posts/stripe-ctf-level1-with-golang/</guid>
      <description>

&lt;p&gt;This year&amp;rsquo;s Stripe-CTF brings some interesting things to the table: Cryptocurrency. I&amp;rsquo;ve already known about cryptocurrency and Bitcoin in general, but it&amp;rsquo;s amazing how Bitcoin relates to Git.&lt;/p&gt;

&lt;p&gt;The level is here:&amp;nbsp;&lt;a href=&#34;https://stripe-ctf.com/levels/1&#34;&gt;https://stripe-ctf.com/levels/1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically, like Bitcoin, you have to find a block, in this case is a git commit. The commit must have its hash lower than the target difficulty, specified in the file difficulty.txt. You will compete against a bot, and you have to find and submit a block/commit before it does.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;m learning Golang, I wrote my miner using it, and managed to bring to 1MHash/s. Some people are going higher, specifically those using OpenCL/GPU to mine.&lt;/p&gt;

&lt;h3 id=&#34;basic:08a8d9808c645f9e5c4f35caf364b6d7&#34;&gt;Basic&lt;/h3&gt;

&lt;p&gt;The first version of my code is very simple. First it will add myself a Gitcoin to the file &amp;ldquo;LEDGER.txt&amp;rdquo;, get the difficulty, and get the required parameters to build the commit. Those tasks will only do once per block found, so any code will work.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;diff = make([]byte, 0)
diffString := strings.Trim(doExec(&#34;cat&#34;, &#34;difficulty.txt&#34;), &#34;\n&#34;)
for i := 0; i &lt; len(diffString)/2; i++ {
     n, _ := strconv.ParseInt(diffString[i*2:i*2+2], 16, 0)
     diff = append(diff, byte(n))
}
tree = strings.Trim(doExec(&#34;git&#34;, &#34;write-tree&#34;), &#34;\n&#34;)
parent = strings.Trim(doExec(&#34;git&#34;, &#34;rev-parse&#34;, &#34;HEAD&#34;), &#34;\n&#34;)
timestamp = strings.Trim(doExec(&#34;date&#34;, &#34;+%s&#34;), &#34;\n&#34;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;I calculate diff as a byte array because SHA1 library returned the hash as an array, so I don&amp;rsquo;t have to convert SHA1 everytime; doExec is just a function to run the command and return console output as a string. The commit hash can be calculate by SHA1 the string &amp;ldquo;commit [len_commit]\0[commit_string]&amp;ldquo;. The commit string can be built by this code:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;baseCommit = fmt.Sprintf(&#34;tree %s\nparent %s\nauthor CTF user &amp;lt;%s@stripe-ctf.com&amp;gt; %s +0000\ncommitter CTF user &amp;lt;%s@stripe-ctf.com&amp;gt; %s +0000\n\nFu[4]ny got a Gitcoin\nnonce 1&#34;, tree, parent, username, timestamp, username, timestamp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;You should already notice the last &amp;ldquo;nonce 1&amp;rdquo; in the commit string, I will replace it with &amp;ldquo;nonce 2&amp;rdquo; and so on until I find a commit with hash lower than difficulty. It&amp;rsquo;s surprisingly simple:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;func getSHA1(n int) [20]byte {
 return sha1.Sum([]byte(baseCommitHash &lt;complete id=&#34;goog_259276313&#34;&gt;+ &lt;/complete&gt;&#34;\n&#34;))
}
func isHashValid(hash [20]byte) bool {
 for i, char := range hash {
  if i &gt;= len(diff) {
   return false
  }
  if char &gt; diff[i] {
   return false
  }
  if char &lt; diff[i] {
   return true
  }
 }
 return false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;After finding a coin, I&amp;rsquo;ll write the commit and push it, I was lazy and just pipe everything to command line. It works but maybe a little slow.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;func pushResult(result chan int, done chan bool) {
    var n int
    for {
        n = &amp;lt;-result
        sem &amp;lt;- 1  // Semaphore git command so only one git command at a time
        c1 := exec.Command(&#34;echo&#34;, getCommit(n, false))
        c2 := exec.Command(&#34;git&#34;, &#34;hash-object&#34;, &#34;-t&#34;, &#34;commit&#34;, &#34;--stdin&#34;, &#34;-w&#34;)
        var err error
        c2.Stdin, err = c1.StdoutPipe()
        if err != nil {
            panic(err)
        }
        c2.Stdout = os.Stdout
        _ = c2.Start()
        _ = c1.Run()
        _ = c2.Wait()
        &amp;lt;-sem
        doExec(&#34;git&#34;, &#34;reset&#34;, &#34;--hard&#34;, fmt.Sprintf(&#34;%x&#34;, getCommitSHA(n)))
        res := doExec(&#34;git&#34;, &#34;push&#34;)
        if res != &#34;error&#34; {
            // done &amp;lt;- true
            // do not stop, just wait for a restart
            time.Sleep(10 * time.Second)
        } else {
            log.Println(&#34;Error when push, waiting for miner to restart&#34;)
            time.Sleep(10 * time.Second)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Then I just loop nonce until I found a coin. I use a result channel to communicate between miner thread and pushResult thread, and a done channel to stop when I find a commit. The bot takes about 10 mins to find a block, with just this version I managed to beat it.&lt;/p&gt;

&lt;h3 id=&#34;optimize-further:08a8d9808c645f9e5c4f35caf364b6d7&#34;&gt;Optimize further&lt;/h3&gt;

&lt;p&gt;After finishing the task, I can join a Gitcoin instance with all players in Stripe-CTF. I knew that I have to optimize it because I can push it only to 200kH/s&lt;/p&gt;

&lt;p&gt;Fortunately, Go has profiling built-in, so I can easily point out that, most of the time my program was waiting for fmt.Sprintf, because I used it to build the commit message.&lt;/p&gt;

&lt;p&gt;So, because the commit is fixed, just the nonce changes, I was able to prebuilt the commit message and the commit hash, just by giving the commit the fixed length and nonce has 16 number. I thought I can create SHA1 with that prebuilt commit and boost the speed of SHA1 function a lot, but I can&amp;rsquo;t, so removing fmt.Sprintf was good for me.&lt;/p&gt;

&lt;p&gt;And by competing with more people, I have to monitor new block, and restart my miner with a new blockchain. I built a channel into the miner, and another gorountine to monitor and send stop signal.&lt;/p&gt;

&lt;p&gt;Once in a while, the miner will check for stop signal and get out of the loop.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;select {
case msg := &amp;lt;-stop:
    if msg {
        // fmt.Printf(&#34;Miner %d stopped! Last i is %d\n&#34;, begin, i)
        break jobOuter
    }
default:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;The monitor function is pretty straightforward, I have two commit hash, last and current, if last commit has different hash than current commit, I do a git hard reset, and send a stop signal.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;func monitor(stop chan bool) {
    var hash, newHash string
    hash = strings.Trim(doExec(&#34;git&#34;, &#34;rev-parse&#34;, &#34;--short&#34;, &#34;origin/master&#34;), &#34;\n&#34;)
    for {
        doExec(&#34;git&#34;, &#34;fetch&#34;, &#34;origin&#34;)
        newHash = strings.Trim(doExec(&#34;git&#34;, &#34;rev-parse&#34;, &#34;--short&#34;, &#34;origin/master&#34;), &#34;\n&#34;)
        if hash != newHash {
            doExec(&#34;git&#34;, &#34;reset&#34;, &#34;--hard&#34;, &#34;origin/master&#34;)
            // log.Println(&#34;New block found! Reseting miners!&#34;)
            stop &amp;lt;- true
            hash = newHash
            time.Sleep(1 * time.Second)
        }
        time.Sleep(1 * time.Second)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s almost be all, things I can/should do better:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I have to calculate SHA1 again everytime I change nonce. I should calculate a base SHA1, and feed nonce for each loop. I can&amp;rsquo;t find anyway to do this now, so I choose to ignore.&lt;/li&gt;
&lt;li&gt;Calling git by command line is bad, maybe use a git library. Sometimes a push does matter, so implement it directly with socket might be good (just the push)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I ended the game with 756 point, with several Gitcoins found. It&amp;rsquo;s very hard to find a coin because I only have 1.5MH/s with all my PCs, so I need a lucky moment to get one.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>